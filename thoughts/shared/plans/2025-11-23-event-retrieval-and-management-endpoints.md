# Event Retrieval and Management Endpoints Implementation Plan

## Overview

Add crucial GET endpoints to the webhook delivery API to enable users to query event status, list events, and manage failed deliveries. This brings the system to production-ready feature parity with industry-standard webhook platforms (Stripe, Twilio, SendGrid).

## Current State Analysis

**Existing Infrastructure:**
- FastAPI application with Mangum adapter for AWS Lambda (`src/api/main.py`)
- Lambda Authorizer with Bearer token authentication and 5-minute caching (`src/authorizer/handler.py`)
- DynamoDB Events table with composite key (tenantId + eventId) and GSI on status + createdAt
- Single POST endpoint: `/v1/events` for event creation (`src/api/routes.py:17`)
- OpenAPI documentation auto-generated by FastAPI at `/v1/docs`, `/v1/redoc`, `/v1/openapi.json`

**What's Missing:**
- ❌ No way to query event status after creation
- ❌ No ability to list events for debugging/monitoring
- ❌ No manual retry mechanism for failed events
- ❌ No tenant configuration management endpoints

**Key Discoveries:**
- FastAPI automatically generates OpenAPI docs from route definitions and Pydantic models
- Lambda Authorizer context flows through `request.scope["aws.event"]["requestContext"]["authorizer"]`
- DynamoDB table has GSI `status-index` ready for querying by status (`cdk/stacks/webhook_delivery_stack.py:112-123`)
- Existing `get_tenant_from_context()` helper extracts tenant info from authorizer (`src/api/context.py:4-30`)
- DynamoDB operations pattern established in `src/api/dynamo.py` and `src/worker/dynamo.py`

## Desired End State

### New API Endpoints:
1. **GET /v1/events** - List all events for authenticated tenant with filtering and pagination
2. **GET /v1/events/{eventId}** - Get detailed status of specific event
3. **POST /v1/events/{eventId}/retry** - Manually retry a failed event
4. **PATCH /v1/tenants/current** - Update tenant configuration (webhook URL, secret)

### Success Verification:
- All endpoints documented in Swagger UI at https://hooks.vincentchan.cloud/v1/docs
- Postman collection updated with working examples
- Users can query event status via API immediately after creation
- Failed events can be manually retried without AWS Console access
- Tenant configuration updatable via API

## What We're NOT Doing

- **Query parameters for authentication** - Sticking with Bearer tokens for consistency
- **Public/unauthenticated endpoints** - All new endpoints require Lambda Authorizer
- **Statistics/analytics endpoint** - Defer GET /v1/stats to future iteration
- **Bulk operations** - POST /v1/events/bulk deferred
- **Webhook-about-webhooks** - Event status change notifications deferred
- **Event export** - CSV/JSON export deferred
- **Event cancellation** - DELETE /v1/events/{eventId} deferred (complexity of canceling in-flight SQS messages)

## Implementation Approach

**Strategy:**
1. Start with read-only operations (GET endpoints)
2. Add DynamoDB query functions before route handlers
3. Define Pydantic response models for type safety and auto-generated docs
4. Leverage existing Lambda Authorizer and tenant context extraction
5. Add write operations (POST retry, PATCH config)
6. Update API Gateway routes to include new endpoints with authorizer
7. Update Postman collection for testing

**Authentication Pattern:**
All endpoints use existing Lambda Authorizer:
- Client sends `Authorization: Bearer <api_key>` header
- API Gateway validates via Lambda Authorizer (5-min cache)
- Tenant context automatically available in request
- No additional auth logic needed in handlers

**Error Handling:**
- 401 Unauthorized - Invalid/missing Bearer token (handled by authorizer)
- 404 Not Found - Event doesn't exist or belongs to different tenant
- 400 Bad Request - Invalid query parameters or malformed request
- 500 Internal Server Error - DynamoDB or infrastructure failures

---

## Phase 1: DynamoDB Query Functions

### Overview
Add query operations to `src/api/dynamo.py` for listing and retrieving events. These functions provide the data access layer for the new GET endpoints.

### Changes Required:

#### 1. Add List Events Query Function
**File**: `src/api/dynamo.py`
**Changes**: Add `list_events()` function after existing `create_event()` function

```python
def list_events(
    tenant_id: str,
    status: Optional[str] = None,
    limit: int = 50,
    last_evaluated_key: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    List events for a tenant with optional status filtering and pagination.

    Args:
        tenant_id: Tenant identifier
        status: Optional status filter (PENDING, DELIVERED, FAILED)
        limit: Maximum number of events to return (default 50, max 100)
        last_evaluated_key: Pagination token from previous response

    Returns:
        {
            "events": [...],
            "lastEvaluatedKey": {...} or None
        }
    """
    limit = min(limit, 100)  # Cap at 100

    if status:
        # Query using GSI when filtering by status
        query_params = {
            "IndexName": "status-index",
            "KeyConditionExpression": "#status = :status",
            "ExpressionAttributeNames": {"#status": "status"},
            "ExpressionAttributeValues": {":status": status},
            "FilterExpression": "tenantId = :tid",
            "ExpressionAttributeValues": {":tid": tenant_id, ":status": status},
            "Limit": limit,
            "ScanIndexForward": False,  # Newest first (descending by createdAt)
        }

        if last_evaluated_key:
            query_params["ExclusiveStartKey"] = last_evaluated_key

        response = events_table.query(**query_params)
    else:
        # Query by tenant_id without status filter
        query_params = {
            "KeyConditionExpression": "tenantId = :tid",
            "ExpressionAttributeValues": {":tid": tenant_id},
            "Limit": limit,
            "ScanIndexForward": False,  # Newest first
        }

        if last_evaluated_key:
            query_params["ExclusiveStartKey"] = last_evaluated_key

        response = events_table.query(**query_params)

    return {
        "events": response.get("Items", []),
        "lastEvaluatedKey": response.get("LastEvaluatedKey"),
    }
```

#### 2. Add Get Single Event Function
**File**: `src/api/dynamo.py`
**Changes**: Add `get_event()` function

```python
def get_event(tenant_id: str, event_id: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve a single event by tenantId and eventId.

    Args:
        tenant_id: Tenant identifier
        event_id: Event identifier

    Returns:
        Event dict or None if not found
    """
    try:
        response = events_table.get_item(
            Key={
                "tenantId": tenant_id,
                "eventId": event_id,
            }
        )
        return response.get("Item")
    except Exception as e:
        print(f"Error retrieving event {event_id} for tenant {tenant_id}: {e}")
        return None
```

#### 3. Add Import Statements
**File**: `src/api/dynamo.py`
**Changes**: Add to imports at top of file

```python
from typing import Dict, Any, Optional
```

### Success Criteria:

#### Automated Verification:
- [x] Python syntax is valid: `python3 -m py_compile src/api/dynamo.py`
- [ ] No linting errors: `ruff check src/api/dynamo.py` (if ruff configured)
- [ ] Lambda can import module successfully (verified in Phase 2 deployment)

#### Manual Verification:
- [ ] `list_events()` returns correct structure with events array and pagination token
- [ ] Status filtering works correctly using GSI
- [ ] Pagination respects limit parameter (capped at 100)
- [ ] `get_event()` returns event dict for valid tenantId + eventId combination
- [ ] Functions handle missing events gracefully (return None/empty list)

---

## Phase 2: Pydantic Response Models

### Overview
Define Pydantic models for API responses to ensure type safety and enable FastAPI's automatic OpenAPI documentation generation.

### Changes Required:

#### 1. Add Response Models
**File**: `src/api/models.py`
**Changes**: Add new model classes after existing `EventCreateResponse`

```python
from typing import Optional, List, Dict, Any
from decimal import Decimal


class EventDetail(BaseModel):
    """Single event with full details"""
    event_id: str
    status: str  # PENDING, DELIVERED, FAILED
    created_at: str  # Unix timestamp as string
    payload: Dict[str, Any]
    target_url: str
    attempts: int
    last_attempt_at: Optional[str] = None
    error_message: Optional[str] = None

    class Config:
        # Allow Decimal from DynamoDB
        json_encoders = {
            Decimal: lambda v: int(v) if v % 1 == 0 else float(v)
        }


class EventListItem(BaseModel):
    """Summary view of event for list endpoint"""
    event_id: str
    status: str
    created_at: str
    attempts: int
    last_attempt_at: Optional[str] = None

    class Config:
        json_encoders = {
            Decimal: lambda v: int(v) if v % 1 == 0 else float(v)
        }


class EventListResponse(BaseModel):
    """Response for GET /v1/events"""
    events: List[EventListItem]
    next_token: Optional[str] = None  # Base64-encoded pagination token
    total_count: int  # Number of events in this response


class EventDetailResponse(BaseModel):
    """Response for GET /v1/events/{eventId}"""
    event: EventDetail


class RetryResponse(BaseModel):
    """Response for POST /v1/events/{eventId}/retry"""
    event_id: str
    status: str  # Should be "PENDING" after retry
    message: str  # "Event requeued for delivery"


class TenantConfigResponse(BaseModel):
    """Response for PATCH /v1/tenants/current"""
    tenant_id: str
    target_url: str
    updated_at: str
    message: str


class TenantConfigUpdate(BaseModel):
    """Request body for PATCH /v1/tenants/current"""
    target_url: Optional[str] = None
    webhook_secret: Optional[str] = None

    class Config:
        # At least one field must be provided
        extra = "forbid"
```

#### 2. Add Pagination Helper
**File**: `src/api/models.py`
**Changes**: Add helper functions at end of file

```python
import base64
import json


def encode_pagination_token(last_evaluated_key: Dict[str, Any]) -> str:
    """Encode DynamoDB LastEvaluatedKey as base64 token"""
    if not last_evaluated_key:
        return None
    return base64.b64encode(json.dumps(last_evaluated_key).encode()).decode()


def decode_pagination_token(token: str) -> Dict[str, Any]:
    """Decode base64 pagination token to DynamoDB key"""
    if not token:
        return None
    try:
        return json.loads(base64.b64decode(token.encode()).decode())
    except Exception:
        return None
```

### Success Criteria:

#### Automated Verification:
- [x] Python syntax is valid: `python3 -m py_compile src/api/models.py`
- [ ] Pydantic models validate correctly: No validation errors when instantiating with sample data
- [ ] Decimal encoder handles DynamoDB numbers correctly

#### Manual Verification:
- [ ] Models serialize to JSON correctly
- [ ] Pagination token encoding/decoding works bidirectionally
- [ ] OpenAPI schema shows correct request/response structures (verified in Phase 5)

---

## Phase 3: GET Endpoints - List and Retrieve Events

### Overview
Implement route handlers for listing and retrieving events. These leverage the DynamoDB functions from Phase 1 and Pydantic models from Phase 2.

### Changes Required:

#### 1. Add GET /v1/events Endpoint
**File**: `src/api/routes.py`
**Changes**: Add new route handler after existing `ingest_event()` function

```python
from typing import Optional
from models import (
    EventListResponse,
    EventListItem,
    EventDetailResponse,
    EventDetail,
    encode_pagination_token,
    decode_pagination_token,
)
from dynamo import list_events, get_event


@router.get("/v1/events", response_model=EventListResponse)
async def list_tenant_events(
    request: Request,
    status: Optional[str] = None,
    limit: int = 50,
    next_token: Optional[str] = None,
):
    """
    List all events for the authenticated tenant.

    Query Parameters:
    - status: Filter by event status (PENDING, DELIVERED, FAILED)
    - limit: Maximum number of events to return (default 50, max 100)
    - next_token: Pagination token from previous response

    Returns paginated list of events with summary information.
    Authentication via Bearer token required (API Gateway Lambda Authorizer).
    """
    # Extract tenant context from Lambda Authorizer
    event = request.scope.get("aws.event", {})

    try:
        tenant = get_tenant_from_context(event)
    except (ValueError, KeyError) as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")

    tenant_id = tenant["tenantId"]

    # Validate status parameter if provided
    if status and status not in ["PENDING", "DELIVERED", "FAILED"]:
        raise HTTPException(
            status_code=400,
            detail="Invalid status. Must be one of: PENDING, DELIVERED, FAILED"
        )

    # Validate and cap limit
    if limit < 1 or limit > 100:
        raise HTTPException(
            status_code=400,
            detail="Invalid limit. Must be between 1 and 100"
        )

    # Decode pagination token
    last_evaluated_key = decode_pagination_token(next_token) if next_token else None

    # Query DynamoDB
    try:
        result = list_events(tenant_id, status=status, limit=limit, last_evaluated_key=last_evaluated_key)
    except Exception as e:
        print(f"Error listing events for tenant {tenant_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve events")

    # Convert to response model
    events_list = [
        EventListItem(
            event_id=item["eventId"],
            status=item["status"],
            created_at=item["createdAt"],
            attempts=item.get("attempts", 0),
            last_attempt_at=item.get("lastAttemptAt"),
        )
        for item in result["events"]
    ]

    # Encode next pagination token
    next_pagination_token = encode_pagination_token(result.get("lastEvaluatedKey"))

    return EventListResponse(
        events=events_list,
        next_token=next_pagination_token,
        total_count=len(events_list),
    )
```

#### 2. Add GET /v1/events/{eventId} Endpoint
**File**: `src/api/routes.py`
**Changes**: Add route handler after `list_tenant_events()`

```python
@router.get("/v1/events/{event_id}", response_model=EventDetailResponse)
async def get_event_details(
    request: Request,
    event_id: str,
):
    """
    Get detailed information about a specific event.

    Path Parameters:
    - event_id: The unique event identifier

    Returns full event details including payload, delivery attempts, and error messages.
    Authentication via Bearer token required (API Gateway Lambda Authorizer).

    Raises:
    - 404: Event not found or does not belong to authenticated tenant
    """
    # Extract tenant context from Lambda Authorizer
    event = request.scope.get("aws.event", {})

    try:
        tenant = get_tenant_from_context(event)
    except (ValueError, KeyError) as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")

    tenant_id = tenant["tenantId"]

    # Retrieve event from DynamoDB
    event_data = get_event(tenant_id, event_id)

    if not event_data:
        raise HTTPException(
            status_code=404,
            detail=f"Event {event_id} not found or does not belong to your tenant"
        )

    # Convert to response model
    event_detail = EventDetail(
        event_id=event_data["eventId"],
        status=event_data["status"],
        created_at=event_data["createdAt"],
        payload=event_data["payload"],
        target_url=event_data["targetUrl"],
        attempts=event_data.get("attempts", 0),
        last_attempt_at=event_data.get("lastAttemptAt"),
        error_message=event_data.get("errorMessage"),
    )

    return EventDetailResponse(event=event_detail)
```

### Success Criteria:

#### Automated Verification:
- [x] Python syntax is valid: `python3 -m py_compile src/api/routes.py`
- [ ] Lambda deployment succeeds: `cdk deploy` completes without errors
- [ ] FastAPI app starts without import errors

#### Manual Verification:
- [ ] GET /v1/events returns 401 without Bearer token
- [ ] GET /v1/events with valid token returns event list for that tenant
- [ ] Status filter works: `?status=FAILED` returns only failed events
- [ ] Pagination works: Response includes next_token when more results available
- [ ] Limit parameter respected: `?limit=10` returns max 10 events
- [ ] GET /v1/events/{eventId} returns 404 for non-existent event
- [ ] GET /v1/events/{eventId} returns 404 for event belonging to different tenant
- [ ] GET /v1/events/{eventId} returns full event details including payload
- [ ] Swagger UI at /v1/docs shows both new endpoints with correct parameters

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 4: POST /v1/events/{eventId}/retry Endpoint

### Overview
Implement manual retry functionality for failed events. This endpoint resets the event status to PENDING and requeues it to SQS for immediate reprocessing.

### Changes Required:

#### 1. Add Retry Function to DynamoDB Module
**File**: `src/api/dynamo.py`
**Changes**: Add `reset_event_for_retry()` function

```python
def reset_event_for_retry(tenant_id: str, event_id: str) -> bool:
    """
    Reset a FAILED event to PENDING status for manual retry.

    Args:
        tenant_id: Tenant identifier
        event_id: Event identifier

    Returns:
        True if event was reset, False if event not found or not in FAILED status
    """
    try:
        # Update only if status is FAILED (prevent retrying PENDING/DELIVERED events)
        response = events_table.update_item(
            Key={
                "tenantId": tenant_id,
                "eventId": event_id,
            },
            UpdateExpression="SET #status = :pending, attempts = :zero REMOVE errorMessage",
            ConditionExpression="#status = :failed",
            ExpressionAttributeNames={"#status": "status"},
            ExpressionAttributeValues={
                ":pending": "PENDING",
                ":failed": "FAILED",
                ":zero": 0,
            },
            ReturnValues="ALL_NEW",
        )
        return True
    except events_table.meta.client.exceptions.ConditionalCheckFailedException:
        # Event is not in FAILED status
        return False
    except Exception as e:
        print(f"Error resetting event {event_id} for retry: {e}")
        return False
```

#### 2. Add Retry Endpoint
**File**: `src/api/routes.py`
**Changes**: Add route handler and import statement

```python
from models import RetryResponse
from dynamo import reset_event_for_retry


@router.post("/v1/events/{event_id}/retry", response_model=RetryResponse)
async def retry_failed_event(
    request: Request,
    event_id: str,
):
    """
    Manually retry a failed event.

    Path Parameters:
    - event_id: The unique event identifier

    This endpoint resets a FAILED event to PENDING status and requeues it
    to SQS for immediate reprocessing. Only events with status=FAILED can be retried.

    Authentication via Bearer token required (API Gateway Lambda Authorizer).

    Raises:
    - 404: Event not found, belongs to different tenant, or not in FAILED status
    - 500: Failed to requeue event
    """
    # Extract tenant context from Lambda Authorizer
    event = request.scope.get("aws.event", {})

    try:
        tenant = get_tenant_from_context(event)
    except (ValueError, KeyError) as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")

    tenant_id = tenant["tenantId"]

    # First verify event exists and belongs to tenant
    event_data = get_event(tenant_id, event_id)

    if not event_data:
        raise HTTPException(
            status_code=404,
            detail=f"Event {event_id} not found or does not belong to your tenant"
        )

    # Check current status
    if event_data["status"] != "FAILED":
        raise HTTPException(
            status_code=400,
            detail=f"Event {event_id} has status '{event_data['status']}'. Only FAILED events can be retried."
        )

    # Reset event to PENDING in DynamoDB
    success = reset_event_for_retry(tenant_id, event_id)

    if not success:
        raise HTTPException(
            status_code=500,
            detail="Failed to reset event status"
        )

    # Requeue to SQS
    message_body = json.dumps({
        "tenantId": tenant_id,
        "eventId": event_id,
    })

    try:
        sqs.send_message(
            QueueUrl=EVENTS_QUEUE_URL,
            MessageBody=message_body,
        )
    except Exception as e:
        print(f"Error requeuing event {event_id} to SQS: {e}")
        raise HTTPException(status_code=500, detail="Failed to requeue event for delivery")

    return RetryResponse(
        event_id=event_id,
        status="PENDING",
        message="Event requeued for delivery"
    )
```

### Success Criteria:

#### Automated Verification:
- [x] Python syntax is valid: `python3 -m py_compile src/api/dynamo.py src/api/routes.py`
- [ ] Lambda deployment succeeds: `cdk deploy` completes without errors
- [ ] No import errors when Lambda starts

#### Manual Verification:
- [ ] POST /v1/events/{eventId}/retry returns 401 without Bearer token
- [ ] Endpoint returns 404 for non-existent event
- [ ] Endpoint returns 404 for event belonging to different tenant
- [ ] Endpoint returns 400 when trying to retry PENDING event
- [ ] Endpoint returns 400 when trying to retry DELIVERED event
- [ ] Successfully retries FAILED event (status changes to PENDING)
- [ ] Event appears in SQS queue after retry
- [ ] Worker Lambda processes retried event normally
- [ ] Attempts counter resets to 0 after retry
- [ ] Error message removed from event after retry
- [ ] Swagger UI shows retry endpoint with correct parameters

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 5: PATCH /v1/tenants/current Endpoint

### Overview
Allow tenants to update their webhook configuration (target URL and webhook secret) via API instead of requiring manual DynamoDB updates.

### Changes Required:

#### 1. Add Tenant Update Function
**File**: `src/api/dynamo.py`
**Changes**: Add `update_tenant_config()` function

```python
import time

def update_tenant_config(
    api_key: str,
    target_url: Optional[str] = None,
    webhook_secret: Optional[str] = None
) -> Dict[str, Any]:
    """
    Update tenant configuration (webhook URL and/or secret).

    Args:
        api_key: API key (partition key in TenantApiKeys table)
        target_url: New webhook URL (optional)
        webhook_secret: New webhook secret (optional)

    Returns:
        Updated tenant configuration
    """
    tenant_api_keys_table = dynamodb.Table(os.environ["TENANT_API_KEYS_TABLE"])

    # Build update expression dynamically
    update_parts = []
    attr_values = {}

    if target_url:
        update_parts.append("targetUrl = :url")
        attr_values[":url"] = target_url

    if webhook_secret:
        update_parts.append("webhookSecret = :secret")
        attr_values[":secret"] = webhook_secret

    if not update_parts:
        raise ValueError("At least one field must be updated")

    # Add updatedAt timestamp
    update_parts.append("updatedAt = :timestamp")
    attr_values[":timestamp"] = str(int(time.time()))

    update_expression = "SET " + ", ".join(update_parts)

    try:
        response = tenant_api_keys_table.update_item(
            Key={"apiKey": api_key},
            UpdateExpression=update_expression,
            ExpressionAttributeValues=attr_values,
            ReturnValues="ALL_NEW",
        )
        return response["Attributes"]
    except Exception as e:
        print(f"Error updating tenant config for API key {api_key}: {e}")
        raise
```

#### 2. Add Config Update Endpoint
**File**: `src/api/routes.py`
**Changes**: Add route handler after retry endpoint

```python
from models import TenantConfigUpdate, TenantConfigResponse
from dynamo import update_tenant_config


@router.patch("/v1/tenants/current", response_model=TenantConfigResponse)
async def update_tenant_configuration(
    request: Request,
    config: TenantConfigUpdate,
):
    """
    Update tenant webhook configuration.

    Request Body:
    - target_url: New webhook delivery URL (optional)
    - webhook_secret: New HMAC secret for signature validation (optional)

    At least one field must be provided. Changes take effect immediately for new events.
    Authentication via Bearer token required (API Gateway Lambda Authorizer).

    Security Note: Updating webhook_secret will invalidate signatures on in-flight webhooks.
    """
    # Extract tenant context from Lambda Authorizer
    event = request.scope.get("aws.event", {})

    try:
        tenant = get_tenant_from_context(event)
    except (ValueError, KeyError) as e:
        raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")

    tenant_id = tenant["tenantId"]

    # Get API key from authorizer context
    # The API key is not in authorizer context, but we can extract it from the Authorization header
    auth_header = event.get("headers", {}).get("authorization") or event.get("headers", {}).get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")

    api_key = auth_header[7:]  # Remove "Bearer " prefix

    # Validate at least one field is provided
    if not config.target_url and not config.webhook_secret:
        raise HTTPException(
            status_code=400,
            detail="At least one field (target_url or webhook_secret) must be provided"
        )

    # Update tenant configuration
    try:
        updated_config = update_tenant_config(
            api_key=api_key,
            target_url=config.target_url,
            webhook_secret=config.webhook_secret,
        )
    except Exception as e:
        print(f"Error updating tenant config for {tenant_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to update tenant configuration")

    return TenantConfigResponse(
        tenant_id=tenant_id,
        target_url=updated_config["targetUrl"],
        updated_at=updated_config["updatedAt"],
        message="Tenant configuration updated successfully"
    )
```

#### 3. Grant API Lambda Write Access to TenantApiKeys
**File**: `cdk/stacks/webhook_delivery_stack.py`
**Changes**: Update permissions around line 236

```python
# Change from read-only to read-write
self.tenant_api_keys_table.grant_read_write_data(self.api_lambda)
self.events_table.grant_read_write_data(self.api_lambda)
self.events_queue.grant_send_messages(self.api_lambda)
```

### Success Criteria:

#### Automated Verification:
- [x] Python syntax is valid: `python3 -m py_compile src/api/dynamo.py src/api/routes.py`
- [ ] Lambda deployment succeeds: `cdk deploy` completes without errors
- [x] IAM permissions updated: API Lambda has UpdateItem permission on TenantApiKeys table

#### Manual Verification:
- [ ] PATCH /v1/tenants/current returns 401 without Bearer token
- [ ] Endpoint returns 400 when request body is empty
- [ ] Successfully updates target_url only: New URL stored in DynamoDB
- [ ] Successfully updates webhook_secret only: New secret stored in DynamoDB
- [ ] Successfully updates both fields simultaneously
- [ ] updatedAt timestamp is set correctly
- [ ] New events use updated targetUrl for delivery
- [ ] Worker Lambda uses updated webhook_secret for HMAC signatures
- [ ] Lambda Authorizer cache expires (5 min) and picks up new config
- [ ] Swagger UI shows PATCH endpoint with request body schema
- [ ] Cannot update configuration for different tenant (tenant isolation maintained)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 6: API Gateway Routes Configuration

### Overview
Add API Gateway routes for the new endpoints and configure them to use the Lambda Authorizer. This makes the endpoints accessible via the custom domain.

### Changes Required:

#### 1. Update API Gateway Configuration
**File**: `cdk/stacks/webhook_delivery_stack.py`
**Changes**: Modify the API Gateway section around lines 358-384

**Current State (lines 358-384):**
```python
# v1 resource group
v1_resource = self.api.root.add_resource("v1")

# Documentation resources (no auth required)
docs_resource = v1_resource.add_resource("docs")
docs_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

redoc_resource = v1_resource.add_resource("redoc")
redoc_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

openapi_resource = v1_resource.add_resource("openapi.json")
openapi_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

# Events endpoint (with authorizer)
events_resource = v1_resource.add_resource("events")
events_resource.add_method(
    "POST",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
)
```

**New Configuration (replace above section):**
```python
# v1 resource group
v1_resource = self.api.root.add_resource("v1")

# Documentation resources (no auth required)
docs_resource = v1_resource.add_resource("docs")
docs_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

redoc_resource = v1_resource.add_resource("redoc")
redoc_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

openapi_resource = v1_resource.add_resource("openapi.json")
openapi_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
)

# Events endpoints (all with authorizer)
events_resource = v1_resource.add_resource("events")

# POST /v1/events - Create event
events_resource.add_method(
    "POST",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
)

# GET /v1/events - List events
events_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
    request_parameters={
        "method.request.querystring.status": False,
        "method.request.querystring.limit": False,
        "method.request.querystring.next_token": False,
    },
)

# GET /v1/events/{eventId} - Get event details
event_id_resource = events_resource.add_resource("{eventId}")
event_id_resource.add_method(
    "GET",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
    request_parameters={
        "method.request.path.eventId": True,
    },
)

# POST /v1/events/{eventId}/retry - Retry failed event
retry_resource = event_id_resource.add_resource("retry")
retry_resource.add_method(
    "POST",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
)

# Tenants endpoints
tenants_resource = v1_resource.add_resource("tenants")
current_tenant_resource = tenants_resource.add_resource("current")

# PATCH /v1/tenants/current - Update tenant config
current_tenant_resource.add_method(
    "PATCH",
    apigateway.LambdaIntegration(self.api_lambda, proxy=True),
    authorization_type=apigateway.AuthorizationType.CUSTOM,
    authorizer=self.token_authorizer,
)
```

### Success Criteria:

#### Automated Verification:
- [x] CDK synth completes without errors: `cdk synth`
- [x] CDK diff shows expected changes: `cdk diff`
- [x] CDK deploy succeeds: `cdk deploy`
- [x] CloudFormation stack updates successfully
- [ ] No API Gateway 5xx errors in CloudWatch Logs after deployment

#### Manual Verification:
- [ ] All endpoints accessible via custom domain https://hooks.vincentchan.cloud
- [ ] GET /v1/events requires Bearer token (401 without)
- [ ] GET /v1/events/{eventId} requires Bearer token (401 without)
- [ ] POST /v1/events/{eventId}/retry requires Bearer token (401 without)
- [ ] PATCH /v1/tenants/current requires Bearer token (401 without)
- [ ] Query parameters pass through correctly on GET /v1/events
- [ ] Path parameter {eventId} routes correctly
- [ ] Lambda Authorizer caching works (same token doesn't re-invoke authorizer within 5 minutes)
- [ ] CORS headers present on all endpoints
- [ ] Documentation endpoints still work without auth (/v1/docs, /v1/redoc, /v1/openapi.json)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 7: Update Postman Collection

### Overview
Add the new endpoints to the Postman collection with working examples and auto-generated tests.

### Changes Required:

#### 1. Update Postman Collection
**File**: `postman_collection.json`
**Changes**: Add new requests to the collection

**Add to "2. Event Ingestion" folder after "Create Event - Order Created":**

```json
{
  "name": "List Events - All",
  "event": [
    {
      "listen": "test",
      "script": {
        "exec": [
          "pm.test('Status is 200', function() {",
          "    pm.response.to.have.status(200);",
          "});",
          "",
          "pm.test('Response has events array', function() {",
          "    const response = pm.response.json();",
          "    pm.expect(response).to.have.property('events');",
          "    pm.expect(response.events).to.be.an('array');",
          "});",
          "",
          "// Save first event ID for detail lookup",
          "if (pm.response.json().events.length > 0) {",
          "    pm.collectionVariables.set('event_id', pm.response.json().events[0].event_id);",
          "}"
        ],
        "type": "text/javascript"
      }
    }
  ],
  "request": {
    "method": "GET",
    "header": [
      {
        "key": "Authorization",
        "value": "Bearer {{api_key}}",
        "type": "text"
      }
    ],
    "url": {
      "raw": "{{api_base_url}}/v1/events",
      "host": ["{{api_base_url}}"],
      "path": ["v1", "events"]
    },
    "description": "List all events for authenticated tenant"
  }
},
{
  "name": "List Events - Failed Only",
  "request": {
    "method": "GET",
    "header": [
      {
        "key": "Authorization",
        "value": "Bearer {{api_key}}",
        "type": "text"
      }
    ],
    "url": {
      "raw": "{{api_base_url}}/v1/events?status=FAILED&limit=20",
      "host": ["{{api_base_url}}"],
      "path": ["v1", "events"],
      "query": [
        {
          "key": "status",
          "value": "FAILED"
        },
        {
          "key": "limit",
          "value": "20"
        }
      ]
    },
    "description": "List only failed events with limit"
  }
},
{
  "name": "Get Event Details",
  "request": {
    "method": "GET",
    "header": [
      {
        "key": "Authorization",
        "value": "Bearer {{api_key}}",
        "type": "text"
      }
    ],
    "url": {
      "raw": "{{api_base_url}}/v1/events/{{event_id}}",
      "host": ["{{api_base_url}}"],
      "path": ["v1", "events", "{{event_id}}"]
    },
    "description": "Get detailed information about a specific event (uses event_id from previous response)"
  }
},
{
  "name": "Retry Failed Event",
  "event": [
    {
      "listen": "test",
      "script": {
        "exec": [
          "pm.test('Status is 200', function() {",
          "    pm.response.to.have.status(200);",
          "});",
          "",
          "pm.test('Event status is PENDING after retry', function() {",
          "    const response = pm.response.json();",
          "    pm.expect(response.status).to.equal('PENDING');",
          "});"
        ],
        "type": "text/javascript"
      }
    }
  ],
  "request": {
    "method": "POST",
    "header": [
      {
        "key": "Authorization",
        "value": "Bearer {{api_key}}",
        "type": "text"
      }
    ],
    "url": {
      "raw": "{{api_base_url}}/v1/events/{{event_id}}/retry",
      "host": ["{{api_base_url}}"],
      "path": ["v1", "events", "{{event_id}}", "retry"]
    },
    "description": "Manually retry a failed event (only works for FAILED events)"
  }
}
```

**Add new folder "6. Tenant Configuration" after "5. Testing & Monitoring":**

```json
{
  "name": "6. Tenant Configuration",
  "item": [
    {
      "name": "Update Webhook URL",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "pm.test('Status is 200', function() {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "pm.test('Configuration updated', function() {",
              "    const response = pm.response.json();",
              "    pm.expect(response.message).to.include('updated');",
              "});"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "PATCH",
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer {{api_key}}",
            "type": "text"
          },
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"target_url\": \"https://receiver.vincentchan.cloud/{{tenant_id}}/webhook\"\n}"
        },
        "url": {
          "raw": "{{api_base_url}}/v1/tenants/current",
          "host": ["{{api_base_url}}"],
          "path": ["v1", "tenants", "current"]
        },
        "description": "Update webhook delivery URL for current tenant"
      }
    },
    {
      "name": "Update Webhook Secret",
      "request": {
        "method": "PATCH",
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer {{api_key}}",
            "type": "text"
          },
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"webhook_secret\": \"whsec_{{$randomAlphaNumeric}}{{$randomAlphaNumeric}}{{$randomAlphaNumeric}}\"\n}"
        },
        "url": {
          "raw": "{{api_base_url}}/v1/tenants/current",
          "host": ["{{api_base_url}}"],
          "path": ["v1", "tenants", "current"]
        },
        "description": "Rotate webhook secret for HMAC signature validation"
      }
    },
    {
      "name": "Update Both URL and Secret",
      "request": {
        "method": "PATCH",
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer {{api_key}}",
            "type": "text"
          },
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"target_url\": \"https://receiver.vincentchan.cloud/{{tenant_id}}/webhook\",\n  \"webhook_secret\": \"whsec_{{$randomAlphaNumeric}}{{$randomAlphaNumeric}}{{$randomAlphaNumeric}}\"\n}"
        },
        "url": {
          "raw": "{{api_base_url}}/v1/tenants/current",
          "host": ["{{api_base_url}}"],
          "path": ["v1", "tenants", "current"]
        },
        "description": "Update both webhook URL and secret simultaneously"
      }
    }
  ],
  "description": "Manage tenant webhook configuration"
}
```

### Success Criteria:

#### Automated Verification:
- [x] Postman collection JSON is valid: `jq . postman_collection.json > /dev/null`
- [ ] Collection imports successfully into Postman without errors

#### Manual Verification:
- [ ] All new requests execute successfully in Postman
- [ ] List Events request populates event_id variable for subsequent requests
- [ ] Get Event Details uses auto-populated event_id variable
- [ ] Retry endpoint only works on FAILED events (returns 400 for other statuses)
- [ ] Update Webhook URL request successfully changes targetUrl in DynamoDB
- [ ] Update Webhook Secret request successfully changes webhookSecret in DynamoDB
- [ ] Test scripts validate response structure correctly
- [ ] Collection variables (api_key, tenant_id) work correctly

---

## Testing Strategy

### Unit Tests (Optional - can be added later)
Test individual functions in isolation:
- `list_events()` with various filter/pagination combinations
- `get_event()` with valid/invalid tenant+event combinations
- `reset_event_for_retry()` with different event statuses
- `update_tenant_config()` with various field combinations
- Pagination token encoding/decoding

### Integration Tests
End-to-end testing through the API:

**Test Suite 1: Event Listing**
1. Create 5 events via POST /v1/events
2. List all events - verify count = 5
3. List with limit=2 - verify pagination token present
4. Use pagination token to get next page
5. Filter by status=PENDING - verify all returned events have that status

**Test Suite 2: Event Retrieval**
1. Create event and save event_id
2. Get event details - verify payload matches
3. Try to get event with different tenant's Bearer token - expect 404
4. Try to get non-existent event_id - expect 404

**Test Suite 3: Manual Retry**
1. Create event that will fail (use invalid webhook URL)
2. Wait for delivery to fail after retries
3. Verify status=FAILED in GET /v1/events/{eventId}
4. POST to retry endpoint
5. Verify status changes to PENDING
6. Verify event reappears in SQS queue
7. Try to retry again while PENDING - expect 400

**Test Suite 4: Tenant Configuration**
1. Update webhook URL via PATCH endpoint
2. Create new event - verify it uses new URL
3. Update webhook secret
4. Worker delivers webhook with new signature
5. Receiver validates new signature successfully
6. Try to update with empty body - expect 400

### Manual Testing Steps

**Using Swagger UI (https://hooks.vincentchan.cloud/v1/docs):**
1. Click "Authorize" button in Swagger UI
2. Enter Bearer token: `tenant_test-tenant_key`
3. Try each GET endpoint interactively
4. Test query parameters and path parameters
5. Verify response schemas match documentation

**Using Postman Collection:**
1. Import updated postman_collection.json
2. Set collection variables (api_key, tenant_id)
3. Run "List Events - All" request
4. Run "Get Event Details" with auto-populated event_id
5. Create a failed event and test retry endpoint
6. Update tenant configuration and verify changes

**Error Handling Verification:**
1. Remove Bearer token - verify 401 responses
2. Use invalid event_id format - verify 404 responses
3. Set limit > 100 - verify 400 response
4. Set invalid status filter - verify 400 response
5. Retry non-FAILED event - verify 400 response

## Performance Considerations

**DynamoDB Query Optimization:**
- List endpoint uses Query (not Scan) for efficiency
- GSI on status+createdAt enables fast filtering by status
- Pagination limits result set size (max 100 items per request)
- Lambda Authorizer caching reduces DynamoDB reads by ~95%

**Expected Performance:**
- GET /v1/events: <200ms (Query on tenantId)
- GET /v1/events?status=FAILED: <250ms (Query on GSI)
- GET /v1/events/{eventId}: <100ms (GetItem)
- POST /v1/events/{eventId}/retry: <300ms (UpdateItem + SQS SendMessage)
- PATCH /v1/tenants/current: <150ms (UpdateItem)

**Scaling Considerations:**
- DynamoDB pay-per-request scales automatically
- Lambda concurrency: 1000 concurrent executions (AWS default)
- API Gateway throttling: 500 req/s rate limit, 1000 burst (configured)
- Consider adding CloudFront if GET requests exceed 10,000/min

## Migration Notes

**No Breaking Changes:**
- Existing POST /v1/events endpoint unchanged
- All new endpoints additive (no modifications to existing routes)
- DynamoDB schema unchanged (using existing tables and GSI)
- Lambda Authorizer behavior unchanged

**Deployment Strategy:**
- Zero-downtime deployment via CDK
- New routes added to existing API Gateway
- Lambda code updated in-place
- No database migrations required

**Rollback Plan:**
If issues arise:
1. Revert CDK stack: `cdk deploy --rollback`
2. Previous Lambda code automatically restored
3. New API Gateway routes removed
4. No data loss (DynamoDB unchanged)

## References

- Current implementation: `src/api/` directory
- DynamoDB operations: `src/api/dynamo.py`, `src/worker/dynamo.py`
- Authentication flow: `src/authorizer/handler.py`, `src/api/context.py`
- Infrastructure: `cdk/stacks/webhook_delivery_stack.py`
- Similar patterns: Worker Lambda event retrieval (`src/worker/dynamo.py:10-13`)
- OpenAPI docs: Auto-generated by FastAPI at `/v1/docs`
